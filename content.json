{"meta":{"title":"CrazyLeaves","subtitle":null,"description":"一只四处漂流没心没肺的Python后端工程师","author":"CrazyLeaves","url":"https://zifenghuang1.github.io/Blog"},"pages":[{"title":"about","date":"2018-02-24T05:48:06.000Z","updated":"2018-02-24T06:22:48.000Z","comments":true,"path":"about/index.html","permalink":"https://zifenghuang1.github.io/Blog/about/index.html","excerpt":"","text":"西安电子科技大学18届软件工程毕业生，主攻Python后端，折腾分布式系统，目前于上海每天风雨兼程送外卖中。 熟练切换粤语国语，ACG爱好者，人群恐惧症患者，最近为减少生活成本而沉迷厨艺。 人生如逆旅，我亦是行人。 有关Python和后端的技术问题欢迎和我一起讨论，求轻喷_(:з」∠)_。 微信：kiddingme233 QQ: 529342824"},{"title":"categories","date":"2018-02-24T04:29:35.000Z","updated":"2018-02-24T04:30:26.000Z","comments":true,"path":"categories/index.html","permalink":"https://zifenghuang1.github.io/Blog/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-02-24T04:32:38.000Z","updated":"2018-02-24T06:31:06.000Z","comments":true,"path":"tags/index.html","permalink":"https://zifenghuang1.github.io/Blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Programing Languages Part A Note（一）：工欲善其事，必先利其器","slug":"Programing-Languages-Part-A-Note（一）：工欲善其事，必先利其器","date":"2018-05-31T02:32:15.000Z","updated":"2018-05-31T02:48:56.000Z","comments":true,"path":"2018/05/31/Programing-Languages-Part-A-Note（一）：工欲善其事，必先利其器/","link":"","permalink":"https://zifenghuang1.github.io/Blog/2018/05/31/Programing-Languages-Part-A-Note（一）：工欲善其事，必先利其器/","excerpt":"Motivation临近毕业季，每天在学校里面除了写论文就是改论文，生活三点一线略显无聊，于是在知乎上搜索了一下Coursera有什么近期开课的计算机神课，看到回答中提到华盛顿大学的Programing Languages并且评价颇高，果断选择旁听入坑。 Programing Languages是一门中级课程，适用于有学习过一门编程语言背景的学生，其目的是通过讲述几门小众语言来描述编程范式（其中尤其注重函数式编程范式）。整个课程分为三个部分，A部分讲述了SML，B部分讲述了Racket，C部分讲述了Ruby。 俗话说，工欲善其事，必先利其器。在学习SML之前，首先得把SML环境和文本编辑器搭起来，课程里面提倡使用的是具有“神的编辑器”之称的Emacs，当然使用别的编辑器也完全没问题，没有强制要求。 一般来说，环境的搭建和工具的流畅使用很大程度决定了学习一门语言的初期成就感，所以投入一定的时间在这上面还是很值得（比如研究Emacs的用法）。 详细的环境搭建教程可以自行查阅课程提供的material（里面记录的非常详细），我在这里只记录一下在搭建过程中遇到的问题以及是如何解决的。","text":"Motivation临近毕业季，每天在学校里面除了写论文就是改论文，生活三点一线略显无聊，于是在知乎上搜索了一下Coursera有什么近期开课的计算机神课，看到回答中提到华盛顿大学的Programing Languages并且评价颇高，果断选择旁听入坑。 Programing Languages是一门中级课程，适用于有学习过一门编程语言背景的学生，其目的是通过讲述几门小众语言来描述编程范式（其中尤其注重函数式编程范式）。整个课程分为三个部分，A部分讲述了SML，B部分讲述了Racket，C部分讲述了Ruby。 俗话说，工欲善其事，必先利其器。在学习SML之前，首先得把SML环境和文本编辑器搭起来，课程里面提倡使用的是具有“神的编辑器”之称的Emacs，当然使用别的编辑器也完全没问题，没有强制要求。 一般来说，环境的搭建和工具的流畅使用很大程度决定了学习一门语言的初期成就感，所以投入一定的时间在这上面还是很值得（比如研究Emacs的用法）。 详细的环境搭建教程可以自行查阅课程提供的material（里面记录的非常详细），我在这里只记录一下在搭建过程中遇到的问题以及是如何解决的。 Use Coursera Forum如果遇到任何在教程中没有给出解决方案的问题，首先在Coursera Forum里面搜一下，里面基本有问题的解决方法。网页版的Coursera在一些还没开课或者刚刚开课的课程主页上，有可能没有显示论坛的入口，所以一开始我是在ios版的Coursera里面进入论坛的，后来需要在论坛上编辑回复手机版非常不方便，所以Google了一下找到解决方法，发现进入discussion forum的链接是有规律的，比如我现在上的这门课的主页是https://www.coursera.org/learn/programming-languages，只要在链接后面加上/discussions就能直接进入课程论坛了。 如果以上链接打不开，你可能需要首先学会如何科学上网。 SML Environment按照教程在Mac OSX Sierra上安装SML v110.79完之后，然后通过sml命令启动REPL的时候遇到了一个奇怪的错误： 1sml: unable to determine architecture/operating system 在StackOverFlow上面搜了一下发现是79版本的已知bug，80版本这个bug已经修复，解决方法是用brew重装SML或者改一下SML的启动Shell文件，第二种看起来比较省事直接就用第二种吧。 打开/usr/local/smlnj/bin/.arch-n-opsys文件，在下面这个位置加入自己的Mac系统版本即可： 1234567891010*) OPSYS=darwin; HEAP_OPSYS=darwin ;; # MacOS X 10.6 11*) OPSYS=darwin; HEAP_OPSYS=darwin ;; # MacOS X 10.7 12*) OPSYS=darwin; HEAP_OPSYS=darwin ;; # MacOS X 10.8 13*) OPSYS=darwin; HEAP_OPSYS=darwin ;; # MacOS X 10.9 Mavericks 14*) OPSYS=darwin; HEAP_OPSYS=darwin ;; # MacOS X 10.10 Yosemite 15*) OPSYS=darwin; HEAP_OPSYS=darwin ;; # MacOS X 10.11 El Capitan 16*) OPSYS=darwin; HEAP_OPSYS=darwin ;; # MacOS X 10.12 Sierra 17*) OPSYS=darwin; HEAP_OPSYS=darwin ;; # MacOS X 10.13 High Sierra *) exit 1;; Update 在最新的教程里面提示可以安装110.80版本，但是material里面打开的跳转链接似乎仍然是110.79版本，这里大家要注意一点。推荐大家尽量不要装110.79版本，因为79版本还有个bug就是基本库引用不了，在Homework 1中有一道题目的要求就是使用Int.ToString这个库函数，如果是79版本就会报错找不到这个库的路径： 1234unexpected exception (bug?) in SML/NJ: Io [Io: openIn failed on &quot;/Users/jhr/Work/smlnj/osx-dist/smlnj.dst/sml.boot.x86-unix/smlnj/basis/.cm/x86-unix/basis.cm&quot;, No such file or directory] raised at: Basis/Implementation/IO/bin-io-fn.sml:617.25-617.71 ../cm/util/safeio.sml:30.11 ../compiler/TopLevel/interact/evalloop.sml:44.55 在Coursera Forum里面提到更新到80版本就能解决这个问题了，在Mac上已经安装了79版本的同学只需要把80版本的pkg下载下来直接安装即可。 SML Mode InstallationSML Mode是Emacs支持SML REPL的一个插件，基本所有的Key Binding都是从M或者C开头，C就是Control这个大家都懂，但M又是什么呢？M是指Meta键，但Mac键盘上没有Meta键，可以通过将Meta键绑定到Option上面，也可以直接用Alt+b来表示Meta键。需要注意Mac系统本身也带有emacs，因此通过命令行启动的emacs默认是老版本，一些Key Binding是未定义的，可以通过Spotlight来打开新版Emacs。 通过C-x C-f test.sml打开一个命名为test的sml文件以后，再输入C-c C-s将会在Emacs底端弹出sml command，输入sml将进入SML REPL，但是此时弹出了一个很奇怪的错误： 12sml command:smlSearching for program: no such file or directory, sml 搜了一下发现是Emacs在启动的时候没找到sml命令，因此需要在Home目录下编辑Emacs的启动配置文件.emacs（其实教程里面也有提及这个问题，我看漏了。。）: 123# For Mac OSX 10.6 or later(setenv &quot;PATH&quot; (concat &quot;/usr/local/smlnj/bin:&quot; (getenv &quot;PATH&quot;)))(setq exec-path (cons &quot;/usr/local/smlnj/bin&quot; exec-path)) 编辑完成test.sml文件之后，通过C-x C-s保存文件。 Emacs Technique 上图是我常用的一个Emacs工作环境布局，左上角的buffer（在Emacs里面一个编辑窗口被称为buffer）是一个SML REPL，用于运行Homework的test文件；左下角的buffer是编写Homework的文件；右上角的buffer是Homework的test文件；右下角的buffer是一个Command Console，用于显示对文件进行了哪些命令操作。 首先说一下如何弄成这个环境布局： 首先通过C-x C-f打开Homework文件以及test文件，并通过C-x C-s调出SML REPL，此时Emacs上显示的是一个上下布局。 让光标悬浮在上面的buffer中，通过C-x 3将光标停留的buffer水平切分成两个buffer；然后让光标停留在下面的buffer作同样处理，此时Emacs的一个四方格布局已经出来了。 让光标停留在任意一个buffer，通过C-x C-b查看当前打开的所有buffer，在每个buffer中通过C-x b buffer_name切换当前buffer到对应的buffer。 如果想生成我上述的布局，分别是左上角的buffer（光标也要停留在左上角的buffer）：C-x b *sml*；左下角的buffer：C-x b hw1.sml；右上角的buffer：C-x b test_hw1.sml；右下角的buffer：C-x b *Messages* （对应Command Console）。 环境布局弄好之后，通过鼠标点击或者C-x o就能移动光标到不同的buffer。 接下来就是Homework编写的流程了： 在Homework.sml文件编写对应的function，编写完成之后记得要通过C-x C-s保存，Emacs默认是不会自动保存写入的。 在test文件之中编写测试，首行通过use语句引入homework文件，保存。 在SML REPL里面通过use语句引入test文件，核对测试结果。 参考链接：Emacs Splitting Windows 有想要共同刷课的欢迎私信我，Enjoy Code。","categories":[{"name":"Coursera","slug":"Coursera","permalink":"https://zifenghuang1.github.io/Blog/categories/Coursera/"}],"tags":[{"name":"Programing languages","slug":"Programing-languages","permalink":"https://zifenghuang1.github.io/Blog/tags/Programing-languages/"}]},{"title":"Python描述器协议","slug":"Python描述器协议","date":"2018-03-02T15:29:10.000Z","updated":"2018-03-02T15:42:06.000Z","comments":true,"path":"2018/03/02/Python描述器协议/","link":"","permalink":"https://zifenghuang1.github.io/Blog/2018/03/02/Python描述器协议/","excerpt":"Abstract本文将从三个问题来阐述Python Descriptor： 什么是Descriptor？ Descriptor如何被调用？ Non Data Descriptor 与 Data Descriptor有何区别？ 在回答完这三个问题之后，本文还将列举几个使用Descriptor的例子： @Property原理 基于Property实现@cached_property Python函数和方法的区别 ​ 如果之前不了解Python Descriptor，建议先过一遍Descriptor How To Guide。对于英语不过关的同学，也可以看一下中文资源。","text":"Abstract本文将从三个问题来阐述Python Descriptor： 什么是Descriptor？ Descriptor如何被调用？ Non Data Descriptor 与 Data Descriptor有何区别？ 在回答完这三个问题之后，本文还将列举几个使用Descriptor的例子： @Property原理 基于Property实现@cached_property Python函数和方法的区别 ​ 如果之前不了解Python Descriptor，建议先过一遍Descriptor How To Guide。对于英语不过关的同学，也可以看一下中文资源。 什么是Descriptor？123456789101112131415161718192021222324252627282930313233343536class Descriptor(object): def __init__(self): self.val = \"init\" def __get__(self, obj, type=None): \"\"\" return value \"\"\" return self.val def __set__(self, obj, value): \"\"\" return None \"\"\" self.val = value def __delete__(self, obj): \"\"\" return None \"\"\" del self.val class A(object): x = Descriptor() In [2]: a = A()In [3]: a.xOut[3]: 'init'In [4]: a.x = \"change\"In [5]: a.xOut[5]: 'change' 如果一个继承于object的类实现了__get__，__set_\\，__delete__中其中任意一种方法，那么该类的对象就是一个descriptor，在上述例子中a.x就是一个描述器。 为什么一定要继承于object呢？因为descriptor机制只作用于新式类。 Descriptor如何被调用？Descriptor的调用机制是基于Python的属性访问机制的，因此弄清楚Python的属性访问机制是很有必要的。 Before Descriptor在出现Descriptor机制之前，如果访问a.x属性，则Python属性默认的查找顺序是： 1234567891011121314st=&gt;start: a.xcond1=&gt;condition: a.__dict__[&apos;x&apos;]?cond2=&gt;condition: type(a).__dict__[&apos;x&apos;]?cond3=&gt;condition: type(a)的基类.__dict__[&apos;x&apos;]?end1=&gt;end: AttributeErrorend2=&gt;end: returnst-&gt;cond1cond1(yes)-&gt;end2cond1(no)-&gt;cond2cond2(yes)-&gt;end2cond2(no)-&gt;cond3cond3(yes)-&gt;end2cond3(no)-&gt;end1 After Descriptor在出现Descriptor之后，Python对象属性的访问机制就出现了变化，下面以Python代码模拟这一个寻找过程： 123456789101112131415161718192021222324252627282930313233343536def object_getattr(obj, name): value, cls = class_lookup(obj.__class__, name) # 首先判断是否为Data Descriptor if value is not None and hasattr(value, \"__get__\") and hasattr(value, \"__set__\"): return value.__get__(obj, cls) # 判断属性是否在对象的__dict__中（Object Attribute） w = obj.__dict__.get(name) if w is not None: return w if value is not None: # 判断是否为Non Data Descriptor if hasattr(v, \"__get__\"): return v.__get__(obj, cls) else: # 判断是否为普通的类属性 return v raise AttributeError def class_lookup(cls, name): value = cls.__dict__.get(name) if value is not None: return value, cls # 遍历基类寻找属性 for i in cls.__bases__: value, cls = class_lookup(i, name) if value is not None: return value, cls return None, None 在上面的Python代码中很容易可以看到How to Guide中强调的Descriptor优先级是如何保证的：Data Descriptor &gt; Object Attribute &gt; Non Data Descriptor。 有一个想跟大家分享比较特殊的例子是，如果在obj.__dict__中找到的对象是一个descriptor，那么descriptor机制并不会被调用，即a.__dict__[‘x’] = Descriptor()，那么a.x并不会调用__get__方法。 123456789101112131415161718192021class Descriptor(object): def __init__(self, val): self.val = val def __get__(self, obj, type=None): return self.val def __set__(self, obj, val): self.val = val class A(object): passIn [2]: a = A()In [3]: a.__dict__['x'] = Descriptor(\"descriptor\")In [4]: a.xOut[4]: &lt;__main__.Descriptor at 0x10b03c750&gt; 相比Python对象属性的访问机制，Python类属性的访问机制有一点区别： 在Python中，类其实也是一种对象，只不过类是通过MetaClass（元类）生成的，因此Python类属性的访问会将上述的class_lookup函数替换为metaclass_lookup函数。 Object Attribute的查找替换为对class.__mro__的遍历查找，并且在这个查找过程中会判断找到的对象是否拥有__get__方法，如果拥有则调用。 类属性访问机制调用的_get\\_方法传入参数时，obj参数传入None，type参数传入class。 希望更详细地探究Python类属性访问机制的同学可以看这里：object-attribute-lookup-in-python Non Data Descriptor 与 Data Descriptor有何区别？Non Data Descriptor只需实现__get_方法，Data Descriptor需要同时实现\\_get__方法和__set__方法。 如果要实现一个只读的Data Descriptor，那么只需要在__set__方法中抛出异常即可。 Data Descriptor和Non Data Descriptor最大的区别就是上述的优先级问题，当descriptor与obj.__dict__中一个属性同名时： 如果descriptor是一个Data Descriptor，那么返回descriptor.__get__的调用值。 如果descriptor是一个Non Data Descriptor，那么返回obj.__dict__中的属性值。 12345678910111213141516171819202122232425262728293031323334353637class NonDataDescriptor(object): def __init__(self): self.value = \"nondata_descriptor\" def __get__(self, instance, owner): return self.value class DataDescriptor(object): def __init__(self): self.value = \"data_descriptor\" def __get__(self, instance, owner): return self.value def __set__(self, instance, value): self.value = value class Container(object): d1 = NonDataDescriptor() d2 = DataDescriptor() In [14]: c = Container()In [15]: c.__dict__['d1'] = \"nondata\"In [16]: c.__dict__['d2'] = \"data\"In [17]: c.d1Out[17]: 'nondata'In [18]: c.d2Out[18]: 'data_descriptor' @Property原理Property在Python源码中被实现为一个类，通过Property可以快速定义一个Data Descriptor。 Property的纯Python代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839class Property(object): def __init__(self, fget=None, fset=None, fdel=None, doc=None): self.fget = fget self.fset = fset self.fdel = fdel self.__doc__ = doc def __get__(self, obj, type=None): if obj is None: return self if self.fget is None: raise AttributeError(\"UnReadable Attribute.\") return self.fget(obj) def __set__(self, obj, value): if self.fset is None: raise AttributeError(\"can't set Attribute.\") self.fset(obj, value) def __delete__(self, obj): if self.del is None: raise AttributeError(\"can't delete Attribute.\") self.del(obj) def getter(self, fget): return type(self)(fget, fset=self.fset, fdel=self.fdel, doc=self.__doc__) def setter(self, fset): return type(self)(self.fget, fset, fdel=self.fdel, doc=self.__doc__) def deleter(self, fdel): return type(self)(self.fget, self.fset, fdel, self.__doc__) Property的使用方法一般有两种： 123456789101112131415161718# 第一种使用方法：@propertydef a(self): ... @a.setterdef a(self, value) ... # 第二种使用方法a = property()@a.getterdef get_a(): ...@a.setterdef set_a(): ... 有时候常常被@这个符号所迷惑，其实@符号基本可以等价为a = property(a)。 在使用第一种方法时，需要注意setter装饰的方法必须跟property装饰的方法同名，否则setter装饰器将不起作用，stackoverflow上也有关于这个问题的讨论。 基于Property实现@cached_property@cached_property装饰器是一种很常用的轮子，在Django和Werkzeug中都有类似的实现。在实现的时候需要注意以下两点： 实例的更改是否会污染类变量 更新实际的value时是否同时更新了缓存中的值 这是是我一开始写的一个错误实现： 123456789101112131415161718192021222324252627282930313233343536373839class CachedProperty(property): def __init__(self, *args, **kwargs): super(CachedProperty, self).__init__(*args, **kwargs) self._cached_property = None def __get__(self, obj, type=None): if obj is None: return self if self.fget is None: raise AttributeError(\"UnReadable Attribute.\") if self._cached_property is None: self._cached_property = self.fget(obj) return self._cached_property def __set__(self, obj, value): if self.fset is None: raise AttributeError(\"can't set Attribute.\") self.fset(obj, value) self._cached_property = self.fget(obj) def __delete__(self, obj): super(CachedProperty, self).__init__(obj) self._cached_property = None class Container(object): @CachedProperty def attr(self): return self._attr @attr.setter def attr(self, value): self._attr = value 这一种实现哪里出错了呢？它的实例污染了全局变量： 12345678910111213141516In [11]: c1 = Container()In [12]: c1.attr = \"c1 attr\"In [13]: c1.attrOut[13]: 'c1 attr'In [14]: c2 = Container()In [15]: c2.attrOut[15]: 'c1 attr'In [16]: c2.attr = \"c2 attr\"In [17]: c1.attrOut[17]: 'c2 attr' 因此缓存的value不应该绑定在CachedProperty的实例上面，否则每一个Container的实例都能改变其他实例的attr属性，造成了类变量的污染。 正确的实现应该是每个实例的缓存绑定在各自的__dict__变量中： 1234567891011121314151617181920212223242526272829class CachedProperty(property): def __init__(self, *args, **kwargs): super(CachedProperty, self).__init__(*args, **kwargs) def __get__(self, obj, type=None): if obj is None: return self if self.fget is None: raise AttributeError(\"Unreadable attribute\") cached_key = self.fget.__name__ if cached_key not in obj.__dict__: obj.__dict__[cached_key] = self.fget(obj) return obj.__dict__[cached_key] def __set__(self, obj, value): if self.fset is None: raise AttributeError(\"Unset attribute\") self.fset(obj, value) cached_key = self.fget.__name__ obj.__dict__[cached_key] = self.fget(obj) def __delete__(self, obj): super(CachedProperty, self).__delete__(obj) del obj.__dict__[self.fget.__name__] Python函数和方法的区别Function在Python中被实现为一个Non Data Descriptor，以下是Python代码表示的Function： 1234class Function(object): def __get__(self, obj, type=None): return types.MethodType(self, obj, type) 当在类中定义Function的时候，如果直接访问类的__dict__变量，仍能得到一个Function object，此时拿到的还不是一个方法，因为Function 还没有跟实例绑定。 1234567class A(object): def test(self): pass In [2]: A.__dict__['test']Out[2]: &lt;function __main__.test&gt; 当从实例调用方法时，a.test等价于types.MethodType(test, a, None)，此时返回一个bound method，即test function已经绑定了实例a。 当从类调用方法时，A.test等价于types.MethodType(test, None, A)，此时返回的是unbound method。 @classmethodclassmethod需要绑定class，以下是Python代码实现： 12345678910111213class classmethod(object): def __init__(self, f): self.f = f def __get__(self, obj, klass=None): if klass is None: klass = type(obj) def newfunc(*args, **kwargs): return self.f(klass, *args, **kwargs) return newfunc 因此在Python中如果一个类的方法使用了@classmethod，即使从实例调用这个方法，传进去的第一个参数仍然是class。 @staticmethodstaticmethod不需要绑定class，以下是Python代码实现： 1234567class staticmethod(object): def __init__(self, f): self.f = f def __get__(self, obj, type=None) return self.f 参考资料： Descriptor How To Guide 如何理解 Python 的 Descriptor? object-attribute-lookup-in-python(强烈推荐)","categories":[{"name":"Python","slug":"Python","permalink":"https://zifenghuang1.github.io/Blog/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://zifenghuang1.github.io/Blog/tags/Python/"}]},{"title":"Hello,2018","slug":"Hello-2018","date":"2018-02-24T06:25:23.000Z","updated":"2018-02-24T13:43:49.000Z","comments":true,"path":"2018/02/24/Hello-2018/","link":"","permalink":"https://zifenghuang1.github.io/Blog/2018/02/24/Hello-2018/","excerpt":"","text":"博客由CSDN转移到Hexo，新的一年，新的开始。 2018，上海，启航！","categories":[{"name":"living","slug":"living","permalink":"https://zifenghuang1.github.io/Blog/categories/living/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://zifenghuang1.github.io/Blog/tags/生活/"}]}]}