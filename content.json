{"meta":{"title":"CrazyLeaves","subtitle":null,"description":"一只四处漂流没心没肺的Python后端工程师","author":"CrazyLeaves","url":"https://zifenghuang1.github.io/Blog"},"pages":[{"title":"categories","date":"2018-02-24T04:29:35.000Z","updated":"2018-02-24T04:30:26.000Z","comments":true,"path":"categories/index.html","permalink":"https://zifenghuang1.github.io/Blog/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-02-24T05:48:06.000Z","updated":"2018-02-24T06:22:48.000Z","comments":true,"path":"about/index.html","permalink":"https://zifenghuang1.github.io/Blog/about/index.html","excerpt":"","text":"西安电子科技大学18届软件工程毕业生，主攻Python后端，折腾分布式系统，目前于上海每天风雨兼程送外卖中。 熟练切换粤语国语，ACG爱好者，人群恐惧症患者，最近为减少生活成本而沉迷厨艺。 人生如逆旅，我亦是行人。 有关Python和后端的技术问题欢迎和我一起讨论，求轻喷_(:з」∠)_。 微信：kiddingme233 QQ: 529342824"},{"title":"tags","date":"2018-02-24T04:32:38.000Z","updated":"2018-02-24T06:31:06.000Z","comments":true,"path":"tags/index.html","permalink":"https://zifenghuang1.github.io/Blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"用Python实现StatsD Server（一）：蓝图","slug":"用Python实现StatsD-Server（一）：蓝图","date":"2018-08-06T15:24:37.000Z","updated":"2018-08-06T15:26:43.000Z","comments":true,"path":"2018/08/06/用Python实现StatsD-Server（一）：蓝图/","link":"","permalink":"https://zifenghuang1.github.io/Blog/2018/08/06/用Python实现StatsD-Server（一）：蓝图/","excerpt":"对于一名终日奋斗在业务最前线的后端工程师来说，监控打点服务就像是全视之眼，时刻监督着线上数据，并且在故障发生时为工程师们提供诊断信息。","text":"对于一名终日奋斗在业务最前线的后端工程师来说，监控打点服务就像是全视之眼，时刻监督着线上数据，并且在故障发生时为工程师们提供诊断信息。 监控打点服务收集的数据在我看来主要可以分为两类，一类是非业务类数据，一类是业务类数据。一般来说，运维工程师会对非业务类的数据比较关注，如线上服务器CPU负载，内存使用量等；而对于业务团队的后端工程师来说，则更为关注业务类的数据，比如说对于一个负责红包开发的业务团队，就会比较关注红包发放API的QPS，一旦红包发放的QPS相比往日异常，则可能线上出现了业务逻辑上的异常。 说到红包，就顺便说个笑话吧，有一天早上饿了么负责红包业务的工程师收到oncall，线上发红包API的QPS相比往日增加了一倍，怀疑是昨晚的发布导致了红包的异常发放。工程师们仔细地review了代码，发现昨晚发布的代码确实没有问题，半小时后，他们终于发现了原因：美团外卖的服务器挂了😊。 扯回正题，监控打点服务还有一个非常重要的报警功能，一旦某个数据指标达到工程师的阀门值，则通过邮件，短信，钉钉等方法通知工程师。 其实监控打点服务在当今业界已经有很多成熟开源的方案，我现在要实现的只不过是再造一次轮子罢了，但是既然要造轮子，总得清楚这个轮子的结构和功能。那么首先来谈谈，实现一个监控打点服务需要哪些组件。 监控打点服务，主要分为三个组件，分别是Client，Server，Backend： Client可以视为C/S架构中的C，通常作为SOA框架中的一个组件实现，不同的SOA服务通过Client发送打点数据。 Server则可以视为C/S架构中的S，负责收集来自不同服务的打点数据，定期将数据发送到Backend。 Backend可以视为存储磁盘，存储打点数据并提供查询功能，通常实现为一个时序数据库。 接下来我将会通过Python实现Client组件和Server组件，读者只需具有基本的Python基础和后端服务概念即可。 组件关系 Client组件通过StatsD协议与Server进行沟通，Server则根据Backend的沟通协议，定时将收集到的数据存储到Backend之中。 在了解了三个组件的关系以后，下面来逐一分析每个组件需要实现的具体功能。 Client组件指标函数Client组件既然是面向广大后端工程师提供打点服务，那么最重要的莫过于提供打点的指标函数了，StatsD协议中提供了四种比较常见的指标函数： counter：counter函数就是最常见的计数器操作，对某一个key的value进行增加或者减少。 timer：timer函数主要用于表示一个时间段内的数据变化，比如在一段时间内的最大值，最小值，平均值。 gauge：gauge函数与counter函数类似，但是Server会对gauge指标函数的数据进行特殊处理，在存储数据到Backend时不会重置gauge指标函数的数据。 set：set函数的概念类似于Python中的set概念，Server会收集通过set指标函数的unique key，形成一个集合。 之前提到Server会定时将数据存储到Backend中，其中counter，timer，set指标函数相关的数据在发送以后都会重置数据，而gauge指标函数相关的数据则会保留。 两个协议Client与Server之间的沟通需要两个协议，一个是TCP／IP层的协议，一个是文本协议。 TCP／IP层的协议只有两个选择：选择TCP还是UDP，TCP主要用于一些对数据准确性比较重要的场景，比如一天只会发送一次的打点数据；而UDP则适用于短时间内发送大量数据的场景，对于性能也比较友好。 文本协议则选择StatsD协议，协议的规范非常简单： 1&lt;key&gt;:value|type[|@sample_rate] 这里解释一下sample_rate的概念，sample_rate是介于0到1之间的一位小数，假设sample_rate设置为0.1，那么对于同一个key，10次之中大概只会有一次数据会被真正发送到Server中，当Server知道sample_rate为0.1时，就会自动将value乘上10。通过这种抽样的方法，虽然降低了打点数据的准确率，但是进一步提高了数据传输性能。 Server 组件Server组件主要负责收集Client的数据，并将数据定时flush到Backend中。 基本功能 Server需要常驻于程序后台，因此将被实现为守护进程，由init进程管理。 Server需要根据StatsD协议解析外部的数据，并将数据存储于内存的数据结构中。 Server需要实现一个定时器，将数据定时flush到Backend中，可选的定时器模型如多线程模型（threading.Timer），协程模型（gevent）等。 Server需要对接多个Backend，因此需要将Backend的一些基本操作抽象出来。 Server启动时需要从命令行中读取很多的配置参数，一般来说Python的argparse库足以应付大多数的情况，但是这一回我选择使用更为优雅的click，写法则可以参考Gunicorn中settings meta写法。 协议交互Server除了通过StatsD协议与Client进行交互以外，Server还要规定协议与Backend进行交互，以Graphite作为Backend为例，能与Graphite沟通的协议有纯文本的HTTP协议，Python的Pickle协议，AMQP协议等。 Backend组件Backend通常使用开源的分布式时序数据库，在本系列教程中并不会实现，但是有兴趣的同学可以参考graphite的whisper组件，是一个通过Python实现的800多行的时序数据库，这规模大小实在是很有让人一探究竟的冲动。","categories":[{"name":"Python","slug":"Python","permalink":"https://zifenghuang1.github.io/Blog/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://zifenghuang1.github.io/Blog/tags/Python/"},{"name":"StatsD","slug":"StatsD","permalink":"https://zifenghuang1.github.io/Blog/tags/StatsD/"}]},{"title":"Programing Languages Part A Note（一）：工欲善其事，必先利其器","slug":"Programing-Languages-Part-A-Note（一）：工欲善其事，必先利其器","date":"2018-05-31T02:32:15.000Z","updated":"2018-06-12T01:11:34.000Z","comments":true,"path":"2018/05/31/Programing-Languages-Part-A-Note（一）：工欲善其事，必先利其器/","link":"","permalink":"https://zifenghuang1.github.io/Blog/2018/05/31/Programing-Languages-Part-A-Note（一）：工欲善其事，必先利其器/","excerpt":"Motivation临近毕业季，每天在学校里面除了写论文就是改论文，生活三点一线略显无聊，于是在知乎上搜索了一下Coursera有什么近期开课的计算机神课，看到回答中提到华盛顿大学的Programing Languages并且评价颇高，果断选择旁听入坑。 Programing Languages是一门中级课程，适用于有学习过一门编程语言背景的学生，其目的是通过讲述几门小众语言来描述编程范式（其中尤其注重函数式编程范式）。整个课程分为三个部分，A部分讲述了SML，B部分讲述了Racket，C部分讲述了Ruby。 俗话说，工欲善其事，必先利其器。在学习SML之前，首先得把SML环境和文本编辑器搭起来，课程里面提倡使用的是具有“神的编辑器”之称的Emacs，当然使用别的编辑器也完全没问题，没有强制要求。 一般来说，环境的搭建和工具的流畅使用很大程度决定了学习一门语言的初期成就感，所以投入一定的时间在这上面还是很值得（比如研究Emacs的用法）。 详细的环境搭建教程可以自行查阅课程提供的material（里面记录的非常详细），我在这里只记录一下在搭建过程中遇到的问题以及是如何解决的。","text":"Motivation临近毕业季，每天在学校里面除了写论文就是改论文，生活三点一线略显无聊，于是在知乎上搜索了一下Coursera有什么近期开课的计算机神课，看到回答中提到华盛顿大学的Programing Languages并且评价颇高，果断选择旁听入坑。 Programing Languages是一门中级课程，适用于有学习过一门编程语言背景的学生，其目的是通过讲述几门小众语言来描述编程范式（其中尤其注重函数式编程范式）。整个课程分为三个部分，A部分讲述了SML，B部分讲述了Racket，C部分讲述了Ruby。 俗话说，工欲善其事，必先利其器。在学习SML之前，首先得把SML环境和文本编辑器搭起来，课程里面提倡使用的是具有“神的编辑器”之称的Emacs，当然使用别的编辑器也完全没问题，没有强制要求。 一般来说，环境的搭建和工具的流畅使用很大程度决定了学习一门语言的初期成就感，所以投入一定的时间在这上面还是很值得（比如研究Emacs的用法）。 详细的环境搭建教程可以自行查阅课程提供的material（里面记录的非常详细），我在这里只记录一下在搭建过程中遇到的问题以及是如何解决的。 Use Coursera Forum如果遇到任何在教程中没有给出解决方案的问题，首先在Coursera Forum里面搜一下，里面基本有问题的解决方法。网页版的Coursera在一些还没开课或者刚刚开课的课程主页上，有可能没有显示论坛的入口，所以一开始我是在ios版的Coursera里面进入论坛的，后来需要在论坛上编辑回复手机版非常不方便，所以Google了一下找到解决方法，发现进入discussion forum的链接是有规律的，比如我现在上的这门课的主页是https://www.coursera.org/learn/programming-languages，只要在链接后面加上/discussions就能直接进入课程论坛了。 如果以上链接打不开，你可能需要首先学会如何科学上网。 SML Environment按照教程在Mac OSX Sierra上安装SML v110.79完之后，然后通过sml命令启动REPL的时候遇到了一个奇怪的错误： 1sml: unable to determine architecture/operating system 在StackOverFlow上面搜了一下发现是79版本的已知bug，80版本这个bug已经修复，解决方法是用brew重装SML或者改一下SML的启动Shell文件，第二种看起来比较省事直接就用第二种吧。 打开/usr/local/smlnj/bin/.arch-n-opsys文件，在下面这个位置加入自己的Mac系统版本即可： 1234567891010*) OPSYS=darwin; HEAP_OPSYS=darwin ;; # MacOS X 10.6 11*) OPSYS=darwin; HEAP_OPSYS=darwin ;; # MacOS X 10.7 12*) OPSYS=darwin; HEAP_OPSYS=darwin ;; # MacOS X 10.8 13*) OPSYS=darwin; HEAP_OPSYS=darwin ;; # MacOS X 10.9 Mavericks 14*) OPSYS=darwin; HEAP_OPSYS=darwin ;; # MacOS X 10.10 Yosemite 15*) OPSYS=darwin; HEAP_OPSYS=darwin ;; # MacOS X 10.11 El Capitan 16*) OPSYS=darwin; HEAP_OPSYS=darwin ;; # MacOS X 10.12 Sierra 17*) OPSYS=darwin; HEAP_OPSYS=darwin ;; # MacOS X 10.13 High Sierra *) exit 1;; Update 在最新的教程里面提示可以安装110.80版本，但是material里面打开的跳转链接似乎仍然是110.79版本，这里大家要注意一点。推荐大家尽量不要装110.79版本，因为79版本还有个bug就是基本库引用不了，在Homework 1中有一道题目的要求就是使用Int.ToString这个库函数，如果是79版本就会报错找不到这个库的路径： 1234unexpected exception (bug?) in SML/NJ: Io [Io: openIn failed on &quot;/Users/jhr/Work/smlnj/osx-dist/smlnj.dst/sml.boot.x86-unix/smlnj/basis/.cm/x86-unix/basis.cm&quot;, No such file or directory] raised at: Basis/Implementation/IO/bin-io-fn.sml:617.25-617.71 ../cm/util/safeio.sml:30.11 ../compiler/TopLevel/interact/evalloop.sml:44.55 在Coursera Forum里面提到更新到80版本就能解决这个问题了，在Mac上已经安装了79版本的同学只需要把80版本的pkg下载下来直接安装即可。 SML Mode InstallationSML Mode是Emacs支持SML REPL的一个插件，基本所有的Key Binding都是从M或者C开头，C就是Control这个大家都懂，但M又是什么呢？M是指Meta键，但Mac键盘上没有Meta键，可以通过将Meta键绑定到Option上面，也可以直接用Alt+b来表示Meta键。需要注意Mac系统本身也带有emacs，因此通过命令行启动的emacs默认是老版本，一些Key Binding是未定义的，可以通过Spotlight来打开新版Emacs。 通过C-x C-f test.sml打开一个命名为test的sml文件以后，再输入C-c C-s将会在Emacs底端弹出sml command，输入sml将进入SML REPL，但是此时弹出了一个很奇怪的错误： 12sml command:smlSearching for program: no such file or directory, sml 搜了一下发现是Emacs在启动的时候没找到sml命令，因此需要在Home目录下编辑Emacs的启动配置文件.emacs（其实教程里面也有提及这个问题，我看漏了。。）: 123# For Mac OSX 10.6 or later(setenv &quot;PATH&quot; (concat &quot;/usr/local/smlnj/bin:&quot; (getenv &quot;PATH&quot;)))(setq exec-path (cons &quot;/usr/local/smlnj/bin&quot; exec-path)) 编辑完成test.sml文件之后，通过C-x C-s保存文件。 Emacs Technique 上图是我常用的一个Emacs工作环境布局，左上角的buffer（在Emacs里面一个编辑窗口被称为buffer）是一个SML REPL，用于运行Homework的test文件；左下角的buffer是编写Homework的文件；右上角的buffer是Homework的test文件；右下角的buffer是一个Command Console，用于显示对文件进行了哪些命令操作。 首先说一下如何弄成这个环境布局： 首先通过C-x C-f打开Homework文件以及test文件，并通过C-c C-s调出SML REPL，此时Emacs上显示的是一个上下布局。 让光标悬浮在上面的buffer中，通过C-x 3将光标停留的buffer水平切分成两个buffer；然后让光标停留在下面的buffer作同样处理，此时Emacs的一个四方格布局已经出来了。 让光标停留在任意一个buffer，通过C-x C-b查看当前打开的所有buffer，在每个buffer中通过C-x b buffer_name切换当前buffer到对应的buffer。 如果想生成我上述的布局，分别是左上角的buffer（光标也要停留在左上角的buffer）：C-x b *sml*；左下角的buffer：C-x b hw1.sml；右上角的buffer：C-x b test_hw1.sml；右下角的buffer：C-x b *Messages* （对应Command Console）。 环境布局弄好之后，通过鼠标点击或者C-x o就能移动光标到不同的buffer。 接下来就是Homework编写的流程了： 在Homework.sml文件编写对应的function，编写完成之后记得要通过C-x C-s保存，Emacs默认是不会自动保存写入的。 在test文件之中编写测试，首行通过use语句引入homework文件，保存。 在SML REPL里面通过use语句引入test文件，核对测试结果。 参考链接：Emacs Splitting Windows 有想要共同刷课的欢迎私信我，Enjoy Code。","categories":[{"name":"Coursera","slug":"Coursera","permalink":"https://zifenghuang1.github.io/Blog/categories/Coursera/"}],"tags":[{"name":"Programing languages","slug":"Programing-languages","permalink":"https://zifenghuang1.github.io/Blog/tags/Programing-languages/"}]},{"title":"Python描述器协议","slug":"Python描述器协议","date":"2018-03-02T15:29:10.000Z","updated":"2018-03-02T15:42:06.000Z","comments":true,"path":"2018/03/02/Python描述器协议/","link":"","permalink":"https://zifenghuang1.github.io/Blog/2018/03/02/Python描述器协议/","excerpt":"Abstract本文将从三个问题来阐述Python Descriptor： 什么是Descriptor？ Descriptor如何被调用？ Non Data Descriptor 与 Data Descriptor有何区别？ 在回答完这三个问题之后，本文还将列举几个使用Descriptor的例子： @Property原理 基于Property实现@cached_property Python函数和方法的区别 ​ 如果之前不了解Python Descriptor，建议先过一遍Descriptor How To Guide。对于英语不过关的同学，也可以看一下中文资源。","text":"Abstract本文将从三个问题来阐述Python Descriptor： 什么是Descriptor？ Descriptor如何被调用？ Non Data Descriptor 与 Data Descriptor有何区别？ 在回答完这三个问题之后，本文还将列举几个使用Descriptor的例子： @Property原理 基于Property实现@cached_property Python函数和方法的区别 ​ 如果之前不了解Python Descriptor，建议先过一遍Descriptor How To Guide。对于英语不过关的同学，也可以看一下中文资源。 什么是Descriptor？123456789101112131415161718192021222324252627282930313233343536class Descriptor(object): def __init__(self): self.val = \"init\" def __get__(self, obj, type=None): \"\"\" return value \"\"\" return self.val def __set__(self, obj, value): \"\"\" return None \"\"\" self.val = value def __delete__(self, obj): \"\"\" return None \"\"\" del self.val class A(object): x = Descriptor() In [2]: a = A()In [3]: a.xOut[3]: 'init'In [4]: a.x = \"change\"In [5]: a.xOut[5]: 'change' 如果一个继承于object的类实现了__get__，__set_\\，__delete__中其中任意一种方法，那么该类的对象就是一个descriptor，在上述例子中a.x就是一个描述器。 为什么一定要继承于object呢？因为descriptor机制只作用于新式类。 Descriptor如何被调用？Descriptor的调用机制是基于Python的属性访问机制的，因此弄清楚Python的属性访问机制是很有必要的。 Before Descriptor在出现Descriptor机制之前，如果访问a.x属性，则Python属性默认的查找顺序是： After Descriptor在出现Descriptor之后，Python对象属性的访问机制就出现了变化，下面以Python代码模拟这一个寻找过程： 123456789101112131415161718192021222324252627282930313233343536def object_getattr(obj, name): value, cls = class_lookup(obj.__class__, name) # 首先判断是否为Data Descriptor if value is not None and hasattr(value, \"__get__\") and hasattr(value, \"__set__\"): return value.__get__(obj, cls) # 判断属性是否在对象的__dict__中（Object Attribute） w = obj.__dict__.get(name) if w is not None: return w if value is not None: # 判断是否为Non Data Descriptor if hasattr(v, \"__get__\"): return v.__get__(obj, cls) else: # 判断是否为普通的类属性 return v raise AttributeError def class_lookup(cls, name): value = cls.__dict__.get(name) if value is not None: return value, cls # 遍历基类寻找属性 for i in cls.__bases__: value, cls = class_lookup(i, name) if value is not None: return value, cls return None, None 在上面的Python代码中很容易可以看到How to Guide中强调的Descriptor优先级是如何保证的：Data Descriptor &gt; Object Attribute &gt; Non Data Descriptor。 有一个想跟大家分享比较特殊的例子是，如果在obj.__dict__中找到的对象是一个descriptor，那么descriptor机制并不会被调用，即a.__dict__[‘x’] = Descriptor()，那么a.x并不会调用__get__方法。 123456789101112131415161718192021class Descriptor(object): def __init__(self, val): self.val = val def __get__(self, obj, type=None): return self.val def __set__(self, obj, val): self.val = val class A(object): passIn [2]: a = A()In [3]: a.__dict__['x'] = Descriptor(\"descriptor\")In [4]: a.xOut[4]: &lt;__main__.Descriptor at 0x10b03c750&gt; 相比Python对象属性的访问机制，Python类属性的访问机制有一点区别： 在Python中，类其实也是一种对象，只不过类是通过MetaClass（元类）生成的，因此Python类属性的访问会将上述的class_lookup函数替换为metaclass_lookup函数。 Object Attribute的查找替换为对class.__mro__的遍历查找，并且在这个查找过程中会判断找到的对象是否拥有__get__方法，如果拥有则调用。 类属性访问机制调用的_get\\_方法传入参数时，obj参数传入None，type参数传入class。 希望更详细地探究Python类属性访问机制的同学可以看这里：object-attribute-lookup-in-python Non Data Descriptor 与 Data Descriptor有何区别？Non Data Descriptor只需实现__get_方法，Data Descriptor需要同时实现\\_get__方法和__set__方法。 如果要实现一个只读的Data Descriptor，那么只需要在__set__方法中抛出异常即可。 Data Descriptor和Non Data Descriptor最大的区别就是上述的优先级问题，当descriptor与obj.__dict__中一个属性同名时： 如果descriptor是一个Data Descriptor，那么返回descriptor.__get__的调用值。 如果descriptor是一个Non Data Descriptor，那么返回obj.__dict__中的属性值。 12345678910111213141516171819202122232425262728293031323334353637class NonDataDescriptor(object): def __init__(self): self.value = \"nondata_descriptor\" def __get__(self, instance, owner): return self.value class DataDescriptor(object): def __init__(self): self.value = \"data_descriptor\" def __get__(self, instance, owner): return self.value def __set__(self, instance, value): self.value = value class Container(object): d1 = NonDataDescriptor() d2 = DataDescriptor() In [14]: c = Container()In [15]: c.__dict__['d1'] = \"nondata\"In [16]: c.__dict__['d2'] = \"data\"In [17]: c.d1Out[17]: 'nondata'In [18]: c.d2Out[18]: 'data_descriptor' @Property原理Property在Python源码中被实现为一个类，通过Property可以快速定义一个Data Descriptor。 Property的纯Python代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839class Property(object): def __init__(self, fget=None, fset=None, fdel=None, doc=None): self.fget = fget self.fset = fset self.fdel = fdel self.__doc__ = doc def __get__(self, obj, type=None): if obj is None: return self if self.fget is None: raise AttributeError(\"UnReadable Attribute.\") return self.fget(obj) def __set__(self, obj, value): if self.fset is None: raise AttributeError(\"can't set Attribute.\") self.fset(obj, value) def __delete__(self, obj): if self.del is None: raise AttributeError(\"can't delete Attribute.\") self.del(obj) def getter(self, fget): return type(self)(fget, fset=self.fset, fdel=self.fdel, doc=self.__doc__) def setter(self, fset): return type(self)(self.fget, fset, fdel=self.fdel, doc=self.__doc__) def deleter(self, fdel): return type(self)(self.fget, self.fset, fdel, self.__doc__) Property的使用方法一般有两种： 123456789101112131415161718# 第一种使用方法：@propertydef a(self): ... @a.setterdef a(self, value) ... # 第二种使用方法a = property()@a.getterdef get_a(): ...@a.setterdef set_a(): ... 有时候常常被@这个符号所迷惑，其实@符号基本可以等价为a = property(a)。 在使用第一种方法时，需要注意setter装饰的方法必须跟property装饰的方法同名，否则setter装饰器将不起作用，stackoverflow上也有关于这个问题的讨论。 基于Property实现@cached_property@cached_property装饰器是一种很常用的轮子，在Django和Werkzeug中都有类似的实现。在实现的时候需要注意以下两点： 实例的更改是否会污染类变量 更新实际的value时是否同时更新了缓存中的值 这是是我一开始写的一个错误实现： 123456789101112131415161718192021222324252627282930313233343536373839class CachedProperty(property): def __init__(self, *args, **kwargs): super(CachedProperty, self).__init__(*args, **kwargs) self._cached_property = None def __get__(self, obj, type=None): if obj is None: return self if self.fget is None: raise AttributeError(\"UnReadable Attribute.\") if self._cached_property is None: self._cached_property = self.fget(obj) return self._cached_property def __set__(self, obj, value): if self.fset is None: raise AttributeError(\"can't set Attribute.\") self.fset(obj, value) self._cached_property = self.fget(obj) def __delete__(self, obj): super(CachedProperty, self).__init__(obj) self._cached_property = None class Container(object): @CachedProperty def attr(self): return self._attr @attr.setter def attr(self, value): self._attr = value 这一种实现哪里出错了呢？它的实例污染了全局变量： 12345678910111213141516In [11]: c1 = Container()In [12]: c1.attr = \"c1 attr\"In [13]: c1.attrOut[13]: 'c1 attr'In [14]: c2 = Container()In [15]: c2.attrOut[15]: 'c1 attr'In [16]: c2.attr = \"c2 attr\"In [17]: c1.attrOut[17]: 'c2 attr' 因此缓存的value不应该绑定在CachedProperty的实例上面，否则每一个Container的实例都能改变其他实例的attr属性，造成了类变量的污染。 正确的实现应该是每个实例的缓存绑定在各自的__dict__变量中： 1234567891011121314151617181920212223242526272829class CachedProperty(property): def __init__(self, *args, **kwargs): super(CachedProperty, self).__init__(*args, **kwargs) def __get__(self, obj, type=None): if obj is None: return self if self.fget is None: raise AttributeError(\"Unreadable attribute\") cached_key = self.fget.__name__ if cached_key not in obj.__dict__: obj.__dict__[cached_key] = self.fget(obj) return obj.__dict__[cached_key] def __set__(self, obj, value): if self.fset is None: raise AttributeError(\"Unset attribute\") self.fset(obj, value) cached_key = self.fget.__name__ obj.__dict__[cached_key] = self.fget(obj) def __delete__(self, obj): super(CachedProperty, self).__delete__(obj) del obj.__dict__[self.fget.__name__] Python函数和方法的区别Function在Python中被实现为一个Non Data Descriptor，以下是Python代码表示的Function： 1234class Function(object): def __get__(self, obj, type=None): return types.MethodType(self, obj, type) 当在类中定义Function的时候，如果直接访问类的__dict__变量，仍能得到一个Function object，此时拿到的还不是一个方法，因为Function 还没有跟实例绑定。 1234567class A(object): def test(self): pass In [2]: A.__dict__['test']Out[2]: &lt;function __main__.test&gt; 当从实例调用方法时，a.test等价于types.MethodType(test, a, None)，此时返回一个bound method，即test function已经绑定了实例a。 当从类调用方法时，A.test等价于types.MethodType(test, None, A)，此时返回的是unbound method。 @classmethodclassmethod需要绑定class，以下是Python代码实现： 12345678910111213class classmethod(object): def __init__(self, f): self.f = f def __get__(self, obj, klass=None): if klass is None: klass = type(obj) def newfunc(*args, **kwargs): return self.f(klass, *args, **kwargs) return newfunc 因此在Python中如果一个类的方法使用了@classmethod，即使从实例调用这个方法，传进去的第一个参数仍然是class。 @staticmethodstaticmethod不需要绑定class，以下是Python代码实现： 1234567class staticmethod(object): def __init__(self, f): self.f = f def __get__(self, obj, type=None) return self.f 参考资料： Descriptor How To Guide 如何理解 Python 的 Descriptor? object-attribute-lookup-in-python(强烈推荐)st=>start: a.x cond1=>condition: a.__dict__['x']? cond2=>condition: type(a).__dict__['x']? cond3=>condition: type(a)的基类.__dict__['x']? end1=>end: AttributeError end2=>end: return st->cond1 cond1(yes)->end2 cond1(no)->cond2 cond2(yes)->end2 cond2(no)->cond3 cond3(yes)->end2 cond3(no)->end1{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[{"name":"Python","slug":"Python","permalink":"https://zifenghuang1.github.io/Blog/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://zifenghuang1.github.io/Blog/tags/Python/"}]},{"title":"Hello,2018","slug":"Hello-2018","date":"2018-02-24T06:25:23.000Z","updated":"2018-02-24T13:43:49.000Z","comments":true,"path":"2018/02/24/Hello-2018/","link":"","permalink":"https://zifenghuang1.github.io/Blog/2018/02/24/Hello-2018/","excerpt":"","text":"博客由CSDN转移到Hexo，新的一年，新的开始。 2018，上海，启航！","categories":[{"name":"living","slug":"living","permalink":"https://zifenghuang1.github.io/Blog/categories/living/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://zifenghuang1.github.io/Blog/tags/生活/"}]}]}